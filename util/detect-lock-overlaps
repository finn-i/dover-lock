#!/usr/bin/gawk -f

##
##  DOVER utility function which takes two RTTM files as input 
##  and returns regions which overlap with a locked region.
##

BEGIN {
  FS = " "; # Field separator
  output_file = "DOVER/overlaps"; 
  count = 0; # Monitors while loop index
  # print "detecting overlaps in: ", ARGV[1], " and ", ARGV[2] >> output_file;
}

# Loop through the records in the first file
FILENAME == ARGV[1] {
  first_file_length = NR; # Number of records
  while (getline line < FILENAME > 0) {
    nf = split(line, fields); 
    if ($1 == "SPEAKER") {
      # Extract start time, end time and dur_lock state
      start_time[count] = fields[4];
      duration[count] = fields[5];
      end_time[count] = start_time[count] + duration[count];
      speaker[count] = fields[8];
      dur_locked[count] = fields[10];
      spkr_locked[count] = fields[11];
    }
    count++;
  }
}

# Loop through the records in the second file
FILENAME == ARGV[2] {
  o_count = 0;
  while (getline line < FILENAME > 0) {
    nf = split(line, fields);
    if ($1 == "SPEAKER") {
      # Extract start time, end time and dur_lock state from the second file
      other_start_time[o_count] = fields[4];
      other_duration[o_count] = fields[5];
      other_end_time[o_count] = other_start_time[o_count] + other_duration[o_count];
      other_speaker[o_count] = fields[8];
      other_dur_locked[o_count] = fields[10];
      other_spkr_locked[o_count] = fields[11];
      for (k = 0; k < count; k++) {
        # Check for overlap
        if (start_time[k] <= other_end_time[o_count] && other_start_time[o_count] <= end_time[k] ||
            other_start_time[o_count] <= end_time[k] && start_time[k] < other_end_time[o_count]) {
          if (dur_locked[k] == 1 && other_dur_locked[o_count] == 1 || 
              spkr_locked[k] == 1 && other_spkr_locked[o_count] == 1) { # both duration lock OR both speaker lock
            min_start = (start_time[k] < other_start_time[o_count]) ? start_time[k] : other_start_time[o_count]; 
            max_duration = (end_time[k] > other_end_time[o_count]) ? end_time[k]-min_start : other_end_time[o_count]-min_start;
            if (spkr_locked[k] == 1 && other_spkr_locked[o_count] == 1) { # both speaker locked
              if (dur_locked[k] == 1 && other_dur_locked[o_count] == 0) { # ensures duration lock has start/stop priority
                min_start = start_time[k];
                max_duration = duration[k];
              } else if (dur_locked[k] == 0 && other_dur_locked[o_count] == 1) {
                min_start = other_start_time[o_count];
                max_duration = other_duration[o_count];
              }
            }
            # flag conflict: region to change followed by updated start/stop times and speaker name
            print "CONFLICT", ARGV[1], start_time[k], duration[k], 
                  "conflict:"speaker[k]"/"other_speaker[o_count], min_start, max_duration >> output_file;
            print ARGV[2], other_start_time[o_count], other_duration[o_count] >> output_file; # remove extra region (has been merged)
          } else if (dur_locked[k] == 1) { # flag overlapping region for removal
            print ARGV[2], other_start_time[o_count], other_duration[o_count] >> output_file;
          } else if (other_dur_locked[o_count] == 1) { # flag overlapping region for removal
            print ARGV[1], start_time[k], duration[k] >> output_file;
          }
          if (spkr_locked[k] == 1 && other_spkr_locked[o_count] == 0) { # 
            print "RENAME", ARGV[2], other_start_time[o_count], other_duration[o_count], speaker[k] >> output_file;
          } else if (other_spkr_locked[o_count] == 1 && spkr_locked[k] == 0) {
            print "RENAME", ARGV[1], start_time[k], duration[k], other_speaker[o_count] >> output_file;
          }
        }
      }
    }
    o_count++;
  }
}

END {
  close(output_file);
}

